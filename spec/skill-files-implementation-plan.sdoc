# Lexica — Implementation Plan @lexica-impl-plan
{
    # Meta @meta
    {
        author: Michael + Claude
        date: 2026-02-19
        status: Draft — for review
        depends-on: skill-files-design.sdoc
    }

    # Overview @overview
    {
        This document plans the concrete changes needed to make Lexica real. Each
        step is self-contained — an agent or developer can pick up any step cold,
        complete it, commit, and the next session picks up where it left off.

        Each step has a **status** field: pending, in-progress, or done. Update the
        status in this file as work is completed. This document is the single source
        of truth for what has been done and what remains.
    }

    # What Exists Today @current-state
    {
        {[.]
            - **Parser** (\`src/sdoc.js\`, ~1800 lines) — parses all SDOC syntax into
              a clean AST. Node types: scope, paragraph, list, table, code,
              blockquote, hr. Every node tracks lineStart/lineEnd.
            - **Exports** from \`src/sdoc.js\` (line ~1798): \`parseSdoc\`,
              \`extractMeta\`, \`renderFragment\`, \`renderTextParagraphs\`,
              \`renderHtmlDocumentFromParsed\`, \`renderHtmlDocument\`, \`formatSdoc\`.
            - **VS Code extension** (\`src/extension.js\`) — preview, export, browser
              view, document server, formatting, knowledge file authoring commands.
            - **AI skill reference** — \`sdoc_reference\` language model tool registered
              in \`src/extension.js\`. Reads \`SDOC_GUIDE.md\` from extension path and
              returns the full content with a reading guidance preamble.
            - **Tests** — custom test runner in \`test/test-all.js\` (162 tests).
              Pattern: \`test(name, fn)\` with simple \`assert(cond, msg)\`. Run with
              \`node test/test-all.js\`. Also \`test/test-knr.js\` for K&R style tests.
            - **Package commands** declared in \`package.json\`: preview,
              previewToSide, exportHtml, openInBrowser, browseDocs,
              newKnowledgeFile, generateAbout.
        }
    }

    # Phase 1: Directory Convention and Agent Instructions @phase-1
    {
        Establish the convention, write agent instructions, and seed initial
        knowledge files. No code changes required — agents browse \`lexica/\`
        directories directly.

        # 1a. Create AGENTS.md @step-1a
        {
            status: done

            **Create:** \`AGENTS.md\` at the repo root.

            **Content:** Write the following (adapt as needed, but keep the core
            instructions):

            ```markdown
            # Agent Instructions

            ## Project Knowledge

            This project uses the Lexica convention for organising knowledge:

            - \`lexica/\` directories contain project knowledge: skills (how-to),
              docs (reference), plans, and specs.

            These directories appear at the repo root and at module levels. When
            starting a task:

            1. List the \`lexica/\` directory at your working directory and at the
               repo root.
            2. Read filenames to identify relevant knowledge.
            3. Open relevant files and read the About section near the top to confirm
               relevance.
            4. Read only the sections you need — scan headings first.
            5. Check parent directories for broader project-wide knowledge.

            ## SDOC Format

            Knowledge files use the SDOC format (\`.sdoc\`). If you need to write or
            edit SDOC, use the \`sdoc_reference\` tool for the format guide. Start with
            the Quick Reference and Common Mistakes sections.
            ```

            **Verify:** The file exists at repo root. An agent starting a new session
            in this repo would see the instructions and know to check \`lexica/\`.
        }

        # 1b. Create lexica/ directory with sdoc-authoring.sdoc @step-1b
        {
            status: done

            **Create directory:** \`lexica/\` at the repo root.

            **Create file:** \`lexica/sdoc-authoring.sdoc\`

            **Content:** Derive from the Quick Reference section of \`SDOC_GUIDE.md\`
            (lines ~15-200). This is a prescriptive skill file — "how to write SDOC".
            Structure it as:

            ```sdoc
            # SDOC Authoring Guide @sdoc-authoring
            {
                # About @about
                {
                    How to write correct SDOC files. Covers document structure, inline
                    formatting, block types (lists, tables, code, blockquotes), and
                    common mistakes. Read the Quick Reference for everyday authoring.
                    Read Common Mistakes before generating SDOC for the first time.
                }

                # Quick Reference @quick-reference
                {
                    (Extract from SDOC_GUIDE.md Quick Reference section. Include
                    document structure, inline formatting, scope syntax, list syntax,
                    table syntax, code blocks, blockquotes, horizontal rules.)
                }

                # Common Mistakes @common-mistakes
                {
                    (Extract from SDOC_GUIDE.md Common Mistakes section.)
                }
            }
            ```

            **Source material:** \`SDOC_GUIDE.md\` sections "Quick Reference" and
            "Common Mistakes". Do not copy the Full Specification — that stays in
            SDOC_GUIDE.md for edge cases.

            **Verify:** \`lexica/sdoc-authoring.sdoc\` parses without errors
            (\`node -e "const {parseSdoc} = require('./src/sdoc'); const r = parseSdoc(require('fs').readFileSync('lexica/sdoc-authoring.sdoc','utf8')); console.log(r.errors.length + ' errors')"\`).
        }

        # 1c. Ensure knowledge files are discoverable @step-1c
        {
            status: done

            Knowledge files live in \`lexica/\` at the repo root. For this repo,
            the authoring skill is at \`lexica/sdoc-authoring.sdoc\`. Design and
            specification documents stay in \`spec/\` (governance, not knowledge).

            The \`AGENTS.md\` file points agents to both \`lexica/\` and \`spec/\`.

            **Verify:** \`ls lexica/\` shows sdoc-authoring.sdoc. \`ls spec/\` shows
            the Lexica documents. The document browser is unaffected.
        }

        # 1d. Update sdoc_reference tool with reading guidance @step-1d
        {
            status: done

            **File:** \`src/extension.js\` (the \`sdoc_reference\` tool registration).

            **Change:** Modify the \`sdoc_reference\` tool's \`invoke\` method to prepend
            a reading guidance preamble before the SDOC_GUIDE.md content:

            ```javascript
            async invoke(options, token) {
              const guidePath = path.join(context.extensionPath, 'SDOC_GUIDE.md');
              const content = fs.readFileSync(guidePath, 'utf8');
              const preamble = [
                '## Reading Guidance',
                '',
                '- The **Quick Reference** section is sufficient for writing correct SDOC.',
                '- **Common Mistakes** is essential reading for any agent generating SDOC.',
                '- Only read the **Full Specification** for edge cases or parser behaviour questions.',
                '- If this project uses Lexica, check `lexica/` directories for project-specific knowledge.',
                '',
                '---',
                '',
              ].join('\\n');
              return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(preamble + content)
              ]);
            }
            ```

            **Verify:** Rebuild the extension (\`npm run package\`), install it
            (\`code --install-extension dist/*.vsix\`), and confirm the sdoc_reference
            tool output starts with "## Reading Guidance".
        }

        # Phase 1 Checklist @phase-1-checklist
        {
            {[.]
                - \`AGENTS.md\` exists at repo root (step 1a)
                - \`lexica/sdoc-authoring.sdoc\` exists and parses cleanly (step 1b)
                - Knowledge files in \`lexica/\` are discoverable (step 1c)
                - \`sdoc_reference\` tool prepends reading guidance (step 1d)
                - No new dependencies added
            }
        }
    }

    # Phase 2: Parser Extensions @phase-2
    {
        Add utility functions to \`src/sdoc.js\` that future tooling (MCP server,
        VS Code commands) will need. Pure functions on the existing AST — no new
        dependencies, no VS Code coupling.

        All new functions go in \`src/sdoc.js\` before the \`module.exports\` block
        (currently at line ~1798). All new functions are added to \`module.exports\`.
        All tests go in \`test/test-all.js\`, added at the end before the summary
        output.

        # 2a. slugify() @step-2a
        {
            status: done

            **File:** \`src/sdoc.js\` (add before \`module.exports\` at line ~1798)

            **Function signature:** \`function slugify(text)\`

            **Behaviour:**
            {[#]
                1. Strip inline formatting markers: \`*\`, \`~\`, \`\\\`\`, \`_\`
                2. Lowercase the result
                3. Replace runs of non-alphanumeric characters with a single \`-\`
                4. Trim leading and trailing \`-\`
                5. Return the slug string
            }

            **Examples:**
            ```javascript
            slugify("Smart Pointers")     // => "smart-pointers"
            slugify("RAII Pattern")       // => "raii-pattern"
            slugify("C++ Memory Mgmt")   // => "c-memory-mgmt"
            slugify("**Bold Title**")    // => "bold-title"
            slugify("  Spaces  ")        // => "spaces"
            ```

            **Export:** Add \`slugify\` to \`module.exports\`.

            **Tests:** Add to \`test/test-all.js\`:
            ```javascript
            console.log("--- slugify ---");
            test("basic slugify", () => {
              assert(slugify("Smart Pointers") === "smart-pointers");
            });
            test("strips formatting markers", () => {
              assert(slugify("**Bold Title**") === "bold-title");
            });
            test("non-alpha to hyphens", () => {
              assert(slugify("C++ Memory Mgmt") === "c-memory-mgmt");
            });
            test("trims hyphens", () => {
              assert(slugify("  Spaces  ") === "spaces");
            });
            ```

            **Verify:** \`node test/test-all.js\` — all tests pass.
        }

        # 2b. listSections() @step-2b
        {
            status: done

            **File:** \`src/sdoc.js\` (add before \`module.exports\`)

            **Function signature:** \`function listSections(nodes)\`

            **Input:** The \`nodes\` array from \`parseSdoc(text).nodes\`. This is the
            top-level document scope's children (or the root nodes if no document
            scope). Each scope node has: \`type: "scope"\`, \`heading\` (string),
            \`id\` (string or null), \`children\` (array of child nodes).

            **Behaviour:** Walk the top-level scope's children. For each child scope
            that is NOT \@meta and NOT \@about, emit a descriptor:

            ```javascript
            {
              id: node.id,          // explicit @id or null
              derivedId: slugify(node.heading),
              title: node.heading,  // raw heading text
              preview: firstParagraphText(node, 100)  // first ~100 chars
            }
            ```

            The \`firstParagraphText\` helper finds the first paragraph child of the
            scope and returns its text, truncated to ~100 characters (break at word
            boundary, append "..." if truncated).

            **Example:**
            ```javascript
            const r = parseSdoc(\`# Doc { # About @about { desc } # RAII @raii { Resource Acq... } # Smart Pointers { Modern C++... } }\`);
            listSections(r.nodes)
            // => [
            //   { id: "raii", derivedId: "raii", title: "RAII",
            //     preview: "Resource Acq..." },
            //   { id: null, derivedId: "smart-pointers", title: "Smart Pointers",
            //     preview: "Modern C++..." },
            // ]
            ```

            **Export:** Add \`listSections\` to \`module.exports\`.

            **Tests:** Cover: document with @meta and @about (both excluded), scopes
            with and without explicit @ids, preview truncation, empty scope (preview
            is empty string).

            **Verify:** \`node test/test-all.js\` — all tests pass.
        }

        # 2c. extractSection() @step-2c
        {
            status: done

            **File:** \`src/sdoc.js\` (add before \`module.exports\`)

            **Function signature:** \`function extractSection(nodes, sectionId)\`

            **Input:** \`nodes\` from \`parseSdoc().nodes\`, and a string \`sectionId\`.

            **Behaviour:**
            {[#]
                1. Walk the top-level scope's children (scope nodes only).
                2. First pass: look for a scope with an explicit \`id\` matching
                   \`sectionId\` (case-sensitive).
                3. Second pass (if no match): look for a scope whose
                   \`slugify(heading)\` matches \`sectionId\` (case-insensitive).
                4. If found, return \`{ title: node.heading, content: renderToText(node) }\`.
                5. If not found, return \`null\`.
            }

            The \`renderToText(node)\` helper renders the scope's children to plain
            text. Use the existing \`renderTextParagraphs\` function where possible,
            or walk the AST and concatenate paragraph text, list items, code block
            content, etc.

            **Export:** Add \`extractSection\` to \`module.exports\`.

            **Tests:** Cover: match by explicit @id, match by derived slug,
            case-insensitive derived match, no match returns null, first match wins
            when multiple scopes have same derived slug.

            **Verify:** \`node test/test-all.js\` — all tests pass.
        }

        # 2d. extractAbout() @step-2d
        {
            status: done

            **File:** \`src/sdoc.js\` (add before \`module.exports\`)

            **Function signature:** \`function extractAbout(nodes)\`

            **Input:** \`nodes\` from \`parseSdoc().nodes\`.

            **Behaviour:** Find the scope with \`id === "about"\` among the top-level
            scope's children. If found, collect all paragraph text from its children
            and return as a single string (paragraphs joined with spaces). If not
            found, return \`null\`.

            **Example:**
            ```javascript
            const r = parseSdoc(\`# Doc { # About @about { First para. Second para. } # Content { ... } }\`);
            extractAbout(r.nodes)  // => "First para. Second para."
            ```

            **Export:** Add \`extractAbout\` to \`module.exports\`.

            **Tests:** Cover: file with @about (returns text), file without @about
            (returns null), @about with multiple paragraphs (joined), @about with
            non-paragraph children (lists, etc. — decide whether to include or skip).

            **Verify:** \`node test/test-all.js\` — all tests pass.
        }

        # 2e. Enhanced extractMeta() @step-2e
        {
            status: done

            **File:** \`src/sdoc.js\` — modify the existing \`extractMeta\` function.

            **Current behaviour:** Finds \@meta scope, extracts \`style\`, \`header\`,
            \`footer\`, and generic key:value pairs.

            **Change:** Also extract these keys from the key:value pairs:
            {[.]
                - \`uuid\` — string or null
                - \`type\` — string or null (e.g., "skill", "doc")
                - \`tags\` — array of strings, parsed from comma-separated value
                  (e.g., \`tags: cpp, memory, raii\` → \`["cpp", "memory", "raii"]\`)
            }

            Add these to the returned object alongside the existing fields.

            **Example:**
            ```javascript
            const r = parseSdoc(\`# Doc { # Meta @meta { uuid: 550e8400-... \\n type: skill \\n tags: cpp, memory } }\`);
            extractMeta(r.nodes)
            // => { uuid: "550e8400-...", type: "skill", tags: ["cpp", "memory"],
            //      style: null, header: null, footer: null, ... }
            ```

            **Tests:** Cover: meta with uuid/type/tags, meta without them (null/[]),
            tags with spaces around commas, single tag, empty tags value.

            **Verify:** \`node test/test-all.js\` — all existing extractMeta tests
            still pass, plus new tests pass.
        }

        # Phase 2 Checklist @phase-2-checklist
        {
            {[.]
                - \`slugify\` exported and tested (step 2a)
                - \`listSections\` exported and tested (step 2b)
                - \`extractSection\` exported and tested (step 2c)
                - \`extractAbout\` exported and tested (step 2d)
                - \`extractMeta\` enhanced and tested (step 2e)
                - All existing tests still pass
                - No new files or dependencies
            }
        }
    }

    # Phase 3: VS Code Integration @phase-3
    {
        Extend the VS Code extension with knowledge file authoring commands.
        Depends on Phase 2 (uses parser extension functions).

        # 3a. "SDOC: New Knowledge File" command @step-3a
        {
            status: done

            **Files to modify:**
            {[.]
                - \`src/extension.js\` — register the command with
                  \`vscode.commands.registerCommand\`, add to
                  \`context.subscriptions.push\` call
                - \`package.json\` — add to \`contributes.commands\` array
                  with \`"command": "sdoc.newKnowledgeFile"\` and
                  \`"title": "SDOC: New Knowledge File"\`
            }

            **Behaviour:**
            {[#]
                1. Show a quick pick: "Skill" or "Doc"
                2. Show an input box: "Knowledge file title" (e.g., "Error Handling")
                3. Determine target directory: use the explorer context menu URI,
                   the active editor's directory, or the workspace root.
                4. Generate a filename: slugify the title + \`.sdoc\`
                   (e.g., \`error-handling.sdoc\`)
                5. Generate a UUID (use \`crypto.randomUUID()\`)
                6. Write the skeleton file (see template below)
                7. Open the new file in the editor
            }

            Skeleton template for step 6:

            ```sdoc
            # {Title} @{slug}
            {
                # Meta @meta
                {
                    uuid: {generated-uuid}
                    type: {skill|doc}
                    date: {YYYY-MM-DD}
                }

                # About @about
                {
                    (Write a 2-5 line summary of this file's content.)
                }

                # {Title}
                {
                    (Content goes here.)
                }
            }
            ```

            **Verify:** Run the command from the VS Code command palette. Confirm the
            file is created in the right directory with correct skeleton content.
        }

        # 3b. "SDOC: Generate About" command @step-3b
        {
            status: done

            **Files to modify:**
            {[.]
                - \`src/extension.js\` — register the command (same pattern as 3a)
                - \`package.json\` — add \`"command": "sdoc.generateAbout"\`,
                  \`"title": "SDOC: Generate About"\` to contributes.commands
            }

            **Behaviour:**
            {[#]
                1. Get the active editor's document. Guard: must be an .sdoc file.
                2. Parse the document with \`parseSdoc()\`.
                3. Use \`listSections()\` to get section titles and previews.
                4. Build a prompt: "Given these sections of a knowledge file titled
                   '{title}', write a 2-5 line About paragraph summarising what this
                   file covers and when an agent should read it."
                5. Call the VS Code language model API
                   (\`vscode.lm.selectChatModels()\`, then
                   \`model.sendRequest(messages)\`) to generate the about text.
                6. Find the \@about scope in the document. If it exists, replace its
                   content. If not, insert a new \@about scope after \@meta (or at the
                   top if no \@meta).
                7. Apply the edit to the document. The author reviews the result.
            }

            **VS Code LM API pattern:** The extension already uses
            \`vscode.lm.registerTool\` (line 75). For generation, use
            \`vscode.lm.selectChatModels()\` to get an available model, then
            \`model.sendRequest([vscode.LanguageModelChatMessage.User(prompt)])\`.
            Stream the response and collect the text.

            **Verify:** Open an .sdoc file with content sections but no \@about. Run
            the command. Confirm an \@about section appears with a reasonable summary.
        }

        # Phase 3 Checklist @phase-3-checklist
        {
            {[.]
                - \`sdoc.newKnowledgeFile\` command works from palette (step 3a)
                - \`sdoc.generateAbout\` command works from palette (step 3b)
                - Both commands declared in package.json
                - Extension version bumped in package.json
                - Extension builds cleanly (\`npm run package\`)
            }
        }
    }

    # Deferred: Build When Needed @deferred
    {
        Designed but deferred until real usage demands them. Each item has a
        trigger condition. These are not tracked with status fields — they will
        get their own planning when the time comes.

        # MCP Server @deferred-mcp
        {
            **Build when:** 20+ knowledge files across multiple directory levels, or
            agents need search beyond filenames and \@about sections.

            A standalone MCP server wrapping \`listSections()\`,
            \`extractSection()\`, \`extractAbout()\`, and a directory walker. Thin
            wrapper — Phase 2 provides the foundation.
        }

        # Knowledge Discovery Walker @deferred-discovery
        {
            **Build when:** needed by MCP server or other tooling.

            \`discoverKnowledge(workingDir)\` — walk up from working directory,
            collect all files in \`lexica/\` directories, return with scope and
            proximity metadata.
        }

        # Pre-Commit Hook @deferred-hook
        {
            **Build when:** manual UUID management is a burden (~10+ files).

            Script that auto-generates UUIDs for knowledge files missing them.
        }

        # Manifest Generator @deferred-manifest
        {
            **Build when:** needed by MCP server for fast startup or CI for
            validation.

            Walk the tree, emit JSON manifest of all knowledge files with metadata.
        }

        # Generative Merge Gate @deferred-merge-gate
        {
            **Build when:** a team wants automated metadata quality assurance.

            CI pipeline that generates \@about and tags at merge time.
        }

        # Cross-File References @deferred-cross-refs
        {
            **Build when:** enough files to form a knowledge graph worth navigating.

            Syntax and tooling for referencing sections across files.
        }

        # Markdown Section Parser @deferred-markdown
        {
            **Build when:** teams use Markdown knowledge files and want section-level
            progressive disclosure.

            Best-effort heading-based section extraction for .md files.
        }
    }

    # Sequencing @sequencing
    {
        {[table]
            Phase | Depends on | Scope | Ships value
            1. Convention + instructions | Nothing | AGENTS.md + 3 files + small extension edit | Agents discover and use knowledge immediately
            2. Parser extensions | Nothing | ~200 lines in sdoc.js + tests | Foundation for all future tooling
            3. VS Code integration | Phase 2 | ~200 lines in extension.js + package.json | Authors create knowledge files easily
        }

        Phase 1 is the priority. It requires almost no code and delivers immediate
        value — agents start finding project knowledge as soon as AGENTS.md and the
        initial files are in place.

        Phase 2 can happen in parallel. It builds foundation for later tooling but
        is not urgent.

        Phase 3 waits for Phase 2. It adds authoring convenience and can wait until
        knowledge files are being created regularly.
    }

    # Open Questions @plan-questions
    {
        {[.]
            - Should we also create \`CLAUDE.md\` as a symlink to \`AGENTS.md\`? Claude
              Code reads CLAUDE.md automatically. Other tools may need their own
              files (\`.cursorrules\`, etc.).
            - ~~**\`docs/\` collision** — resolved by switching to \`lexica/\` as the
              single directory name. No collision with existing \`docs/\` conventions.~~
            - For step 3b, which VS Code LM API provider to target? The API supports
              multiple providers but the UX and availability differs.
        }
    }
}
