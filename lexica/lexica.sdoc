# Lexica @lexica
{
    # Meta @meta
    {
        type: doc
    }

    # About @about
    {
        Lexica is a system for organising project knowledge so that AI agents and
        developers can find what they need, when they need it, without drowning in
        irrelevant context. It uses a single \`lexica/\` directory placed at any
        level of a project tree, with tooling that lets agents navigate knowledge
        progressively rather than loading everything at once.
    }

    # The Problem @problem
    {
        AI agents need context to be useful. Today, the options are:

        {[.]
            - **Monolithic context files** — dump everything into AGENTS.md or CLAUDE.md.
              Agents get everything whether they need it or not. Context windows fill up
              with irrelevant material. Agents lose focus.
            - **RAG** — embedding-based retrieval guesses what might be relevant. The agent
              has no say in what gets loaded. Structural context (what else is in the file,
              what the prerequisites are) is lost.
            - **Hand-curated tool descriptions** — someone manually writes and maintains
              context for each tool. It drifts. It is always incomplete.
        }

        The underlying problem: knowledge naturally forms a tree (global patterns →
        project conventions → module-specific details), but existing approaches flatten
        it into a single blob or fragment it into disconnected chunks.

        Lexica solves this by giving knowledge a predictable home in the filesystem and
        giving agents tools to navigate it deliberately — seeing the map first, then
        diving into exactly the section they need.
    }

    # How It Works @how-it-works
    {
        # The lexica/ Directory @lexica-directory
        {
            All project knowledge lives in directories named \`lexica/\`. Each file
            is a knowledge document — a skill (how to do something) or a reference
            doc (what something is). The \`type\` field in \@meta distinguishes them;
            the directory is the same either way.

            ```
            repo/
                lexica/                         # Repo-wide knowledge
                    coding-conventions.sdoc        type: skill
                    error-handling.sdoc            type: skill
                    deployment-runbook.sdoc        type: skill
                    architecture.sdoc              type: doc
                    api-contract.sdoc              type: doc
                    roadmap.sdoc                   type: doc
                src/
                    auth/
                        lexica/                 # Auth module knowledge
                            oauth-guide.sdoc      type: skill
                            auth-api-spec.sdoc    type: doc
                            session-lifecycle.sdoc type: doc
                        login.cpp
                        session.cpp
            ```

            One directory, descriptive filenames. The name \`lexica/\` is
            collision-proof — no project uses it for anything else. It is plain
            and visible — no dot-prefix, no hidden folders. Both humans and agents
            browse it directly.
        }

        # Scoped Discovery @scoped-discovery
        {
            An agent's visible knowledge is determined by where it is working.
            Tooling walks upward from the working directory, collecting \`lexica/\`
            at each level:

            ```
            Working in repo/src/auth/:

            1. repo/src/auth/lexica/            (closest — module-specific)
            2. repo/src/lexica/                 (if it exists)
            3. repo/lexica/                     (repo-wide)
            4. ~/lexica/                        (global)
            ```

            Closer knowledge ranks higher. An agent in the auth module sees
            auth-specific knowledge first, then project-wide conventions, then
            global language patterns. Everything is visible, but the most relevant
            knowledge surfaces first.
        }

        # Progressive Disclosure @progressive-disclosure
        {
            Agents navigate knowledge in three steps, each loading only what they need:

            {[#]
                1. **Discovery** — "What knowledge exists?" The agent sees a list of files
                   with short summaries (\@about paragraphs). ~200 tokens for 50 files.
                2. **Orientation** — "What's in this file?" The agent sees the section
                   headings of one file with short previews. ~50-100 tokens.
                3. **Detail** — "Show me this section." The agent loads the full content
                   of one section. ~200-1000 tokens.
            }

            Total context for a targeted lookup: ~750 tokens. The agent saw the map,
            chose the right file, chose the right section, and loaded only that. No
            context pollution.
        }
    }

    # Writing Knowledge Files @writing
    {
        # Minimal Example @minimal-example
        {
            A knowledge file is just content with headings. At minimum:

            ```sdoc
            # Error Handling Conventions
            {
                # General Rules
                {
                    Always use Result types for operations that can fail.
                    Never swallow exceptions silently...
                }

                # HTTP Error Responses
                {
                    All API endpoints return standard error envelopes...
                }

                # Logging
                {
                    Use structured logging with correlation IDs...
                }
            }
            ```

            Put it in a \`lexica/\` directory and it is immediately discoverable.
            No metadata required.
        }

        # Adding Metadata @adding-metadata
        {
            For richer discovery, add an \@about section and \@meta with a type:

            ```sdoc
            # Error Handling Conventions @error-handling
            {
                # Meta @meta
                {
                    type: skill
                }

                # About @about
                {
                    Error handling patterns for this project. Covers Result types,
                    HTTP error envelopes, structured logging, and retry policies.
                    Read this before writing any error handling code.
                }

                # General Rules
                {
                    ...
                }
            }
            ```

            The \@about section can be written by hand or generated by AI tooling
            (see the "SDOC: Generate About" VS Code command).

            The \`type\` field is either \`skill\` (how to do something — prescriptive)
            or \`doc\` (what something is — descriptive). This helps tooling filter
            and rank results but does not affect where the file lives.

            Alternatively, the type can be encoded in the filename as a prefix:
            \`skill-error-handling.sdoc\`, \`doc-architecture.sdoc\`. Tooling infers
            the type from the prefix when \@meta has no \`type\` field. Both
            approaches work; use whichever fits your workflow. If both are
            present, \@meta takes precedence.
        }

        # Where to Put Files @where-to-put
        {
            {[.]
                - **Global knowledge** (\`~/lexica/\`) — things that apply to any project
                  using this language or tool. C++ idioms, Python async patterns, git
                  workflows.
                - **Repo-wide knowledge** (\`repo/lexica/\`) — project architecture,
                  coding conventions, API contracts, project plans.
                - **Module-specific knowledge** (\`src/auth/lexica/\`) — patterns and
                  specs that only matter when working in this module.
            }

            When in doubt, go one level broader. It is easier to find knowledge that
            is too high than knowledge that is buried too deep.
        }
    }

    # Format @format
    {
        Lexica is format-agnostic. Any file in a \`lexica/\` directory is knowledge
        — \`.sdoc\`, \`.md\`, or plain text.

        SDOC provides the richest experience: unambiguous section extraction (braces
        make boundaries explicit), built-in \@meta and \@about support, \@id
        cross-references, and a VS Code extension with live preview and formatting.
        Progressive disclosure works best with SDOC because the tooling can extract
        exactly one section on demand, every time, with no heuristics.

        Markdown works too. Discovery finds Markdown files the same way. Section
        extraction uses heading-level heuristics (best-effort, not guaranteed). Teams
        that prefer Markdown can use it and still get the benefits of scoped discovery
        and progressive disclosure — just with slightly less precise section boundaries.
    }

    # Sharing Knowledge Across Repos @sharing
    {
        Knowledge common across multiple repos (language patterns, organisation-wide
        conventions) lives in a shared repository, mounted as a git submodule:

        ```
        repo/lexica/shared/     ← git submodule pointing to shared knowledge repo
        ```

        The workflow:

        {[#]
            1. Author and review knowledge in the shared repo (normal git flow)
            2. In consuming repos, \`git submodule update --remote\` to pull the latest
            3. Commit the pointer bump — the diff shows what changed
        }

        The usual submodule pain points do not apply: shared knowledge is read-only
        from the consumer's perspective, the submodule is shallow (one, at a known
        location), and updates are deliberate.

        For personal or machine-wide knowledge that does not need to be repo-pinned,
        use the global directory: \`~/lexica/\`.
    }

    # How Agents Use It Today @how-agents-use-it
    {
        Agents browse \`lexica/\` directories directly using their built-in file
        tools (list files, read files). An \`AGENTS.md\` file at the repo root
        teaches agents the convention:

        {[#]
            1. List the \`lexica/\` directory at the working directory and at the
               repo root.
            2. Read filenames to identify relevant knowledge.
            3. Open relevant files and read the \@about section to confirm relevance.
            4. Scan headings and read only the sections needed for the current task.
            5. Check parent directories for broader project-wide knowledge.
        }

        This works well for projects with a manageable number of knowledge files.
        No special tooling is required — any agent that can list directories and read
        files can use Lexica immediately. The \`AGENTS.md\` convention is supported by
        Claude Code, Cursor, Windsurf, and most other agent environments.
    }

    # Future Tooling @future-tooling
    {
        When the number of knowledge files grows large enough that manual browsing
        becomes inefficient (roughly 20+ files across multiple directory levels), an
        MCP server can provide programmatic progressive disclosure:

        {[table]
            Tool | What it does
            list_knowledge | Show all visible knowledge files with summaries, scoped to the working directory
            search | Find knowledge matching a query, ranked by relevance and proximity
            get_sections | Show the section headings of one file with previews
            get_section | Load the full content of one section
        }

        The MCP server would be a thin wrapper around the SDOC parser's section
        extraction capabilities and a directory walker. It enforces progressive
        disclosure by design — there is no "load the whole file" tool.

        This is deliberately deferred. The directory convention delivers value
        immediately with zero dependencies. Tooling gets built when real usage
        demands it.
    }

    # Principles @principles
    {
        {[.]
            - **Author content, generate everything else.** Write knowledge with clear
              headings. Tooling can handle UUIDs, summaries, and metadata as it matures.
            - **One directory: \`lexica/\`.** No hidden folders, no metadata declarations,
              no configuration. Put a file in the directory, it is knowledge. The
              \`type\` field in \@meta distinguishes skills from docs.
            - **Closer knowledge ranks higher.** An agent sees the most relevant knowledge
              first — local to its working directory, then project-wide, then global.
            - **Agents navigate, not search.** Progressive disclosure gives agents agency
              in what they load. They see the map, choose what to explore, and load only
              what they need.
            - **Format-agnostic discovery, SDOC for precision.** Any format is discovered.
              SDOC provides the best tooling for section extraction and metadata.
            - **Strict directory convention.** Knowledge files go in \`lexica/\`. Not
              alongside code, not in hidden directories. Predictable structure means
              trivial discovery.
        }
    }
}
